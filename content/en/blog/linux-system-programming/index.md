---
title: "Linux System Programming"
description: ""
lead: ""
date: 2023-02-28T21:09:04+09:00
lastmod: 2023-02-28T21:09:04+09:00
draft: true
weight: 50
images: ["linux-system-programming.jpg"]
contributors: []
---

![image](https://www.hanbit.co.kr/data/books/B3063338457_l.jpg)

### Introduction

이유야 여럿 있었겠지만 그 중에 하나 생각나는 게 있다면 `epoll`이다. 로봇 소프트웨어를 오랫동안 개발해오면서 그때그때 필요에 의해 사용해야하는 리눅스 시스템 개념들을 한 줌 한 줌 습득해오긴 했어도, 시스템 프로그래밍 전반을 알아본 적은 없었다. 동료들과 논의를 하다보면 주위 개발자들의 입에서 `epoll` 이라는 이름이 나올 때마다 다중화 머시기 정도만 떠오를 뿐 정확한 개념은 몰라 속으로만 허둥대던 순간들이 종종 있었던 것 같다. 어쨌든 이러저러한 이유로 [리눅스 시스템 프로그래밍](https://www.hanbit.co.kr/store/books/look.php?p_code=B5959039025) 책을 한 권 일독하게 되었고 몰랐던 많은 개념들을 알게 되어 읽은 보람을 꽤나 느꼈다. 시스템 프로그래밍을 주업으로 삼고 있지는 않기에 시간이 지나면 책에서 봤던 수많은 내용을 기억할 순 없겠다 싶어 중요하게 깨달았던 몇 가지 개념들을 정리하고 기록으로 남겨두고 싶었다.

### System Programming?

시스템 프로그래밍에는 커널이나 디바이스 드라이버 개발도 포함된다. 하지만 많은 로봇 개발자들에게는 커널 위에 존재하는 사용자 영역에서의 시스템 프로그래밍을 떠올리는 사람들이 많을 것이다. 자바스크립트와 같은 웹 소프트웨어가 하드웨어나 운영체제를 신경쓰지 않고 개발할 수 있을 만큼 추상화된 고급 라이브러리를 사용하는 것을 애플리케이션 프로그래밍이라고 한다면, 시스템 프로그래밍은 커널이 제공하는 시스템 레벨 인터페이스인 시스템 콜을 직접 활용하여 개발하는 것이라고 말할 수 있다. 시스템 프로그래밍에서 자주 언급되는 아래 몇 가지 개념을 정리해보고자 한다.

#### 시스템 콜

시스템 콜을 간단히 정의하면 운영체제에 리소스나 서비스를 요청하려고 사용자 영역에서 시작해서 커널 내부로 들어가는 함수 호출이라고 할 수 있다.

시스템 콜이 필요한 이유는 다음과 같다. 예를 들어 파일 하나를 생성해서 문자열 "Hello"를 기록하는 기능이 필요하다고 생각해보자. 그러면 우리가 사용하는 언어에서 제공하는 파일 입출력 라이브러리를 사용해서 Create 함수와 Write 함수를 호출해서 이 기능을 구현할 것이다. 마치 사용자 프로그램에서 파일을 생성하고 쓰기를 수행하는 것처럼 느껴지지만 실제로는 그렇지 않다. 디스크에 접근해서 파일을 생성하고 쓰기를 수행할 수 있는 것은 커널 프로그램 하나 뿐이며, 보안과 안정성의 이유로 사용자 프로그램이 커널의 코드를 직접 실행하거나 커널 내부 데이터를 조작하는 것은 불가능하다. 애플리케이션은 아키텍처마다 달리 정의된 어떤 메커니즘의 의해서만 파일과 같은 시스템 자원에 대한 조작을 커널에 요청할 수 있는데, 이러한 요청을 우리는 **시스템 콜**이라 부르는 것이다. 시스템 콜이 호출되는 방식은 컴파일러와 C 라이브러리에서 자동으로 처리되므로 시스템 프로그래머가 굳이 알 필요는 없다.

#### C 라이브러리와 C 컴파일러

C 라이브러리는 시스템 콜에 대한 래퍼 함수를 제공하는데, 다른 언어로 개발하더라도 상위 라이브러리에 C 라이브러리가 포함되어 시스템 콜을 처리하기 위해 동작한다. 리눅스에서는 GNU C 라이브러리인 glibc가 제공된다.

시스템 프로그래밍에서 컴파일러는 C 표준과 시스템 ABI 구현에 관여하는 매우 중요한 요소이다. 리눅스는 표준 C 컴파일러로 GCC(GNU Compiler Collection)를 제공한다.

#### API와 ABI

API와 ABI는 시스템 간의 호환성에 영향을 주는 2가지 요소이다.

API(Application Programming Interface)는 소스코드 레벨의 인터페이스를 의미한다. C 표준에서 정의한 C API처럼 약속된 인터페이스를 따라 소스코드를 작성해야만 컴파일이 성공한다.

ABI(Application Binary Interface)는 바이너리 레벨의 인터페이스를 의미한다. 오브젝트 코드를 다시 컴파일할 필요 없이 그대로 사용할 수 있는지 여부를 결정한다. ABI는 애플리케이션 간, 애플리케이션과 라이브러리, 애플리케이션과 커널 간의 상호 동작에 대해 정의한다.

API의 경우에는 컴파일이 되지 않을 때 정의를 찾아봄으로써 쉽게 문제를 해결할 수 있지만, ABI는 런타임에 문제가 발생하기 때문에 트러블슈팅하기가 쉽지 않다. ABI는 콜링 컨벤션, 바이트 순서, 레지스터 활용, 시스템 콜 실행, 라이브러리 링크, 라이브러리 동작 방식, 바이너리 오브젝트 형식 등과 관련이 있다. ABI 대부분은 특정 레지스터나 어셈블리 명령어 같은 하드웨어와 관련된 개념을 다루므로 아키텍처마다 다른 고유의 ABI를 가지는데, x86_64용 바이너리가 aarch64 시스템에서 실행되지 않는 이유가 그것이다. ABI는 컴파일러나 링커와 같은 툴체인에 의해 강제되며 겉으로 드러나지는 않으므로 시스템 프로그래머가 ABI를 깊게 알 필요는 없지만 툴체인이나 어셈블리 코드를 개발한다면 ABI는 반드시 알아야한다.

#### 표준

POSIX(Portable Operating System Interface)와 SUS(Single UNIX Specification)는 유닉스 호환 운영체제 인터페이스를 위한 C API를 명세하고 있다. 리눅스는 공식적으로 POSIX와 SUS 인증을 마친 배포판은 없으나 POSIX와 SUS 호환을 지향하고 있고 그 요구사항에 맞게 동작하도록 노력한다. 리눅스는 자체적으로 편의를 위해 추가된 API 함수를 제공하면서도 표준에 정의된 함수는 반드시 제공하여 사용자가 프로그램 호환성 측면을 고려하고 선택할 수 있도록 한다.

### 파일 입출력

- [ ] write() 동작 방식
- [ ] 다중 입출력: select(), poll()
- [ ] 커널이 입출력을 구현하는 방식: 가상 파일시스템, 페이지 캐시, 페이지 쓰기 저장

### 버퍼 입출력

- [ ] 버퍼 입출력과 표준 입출력
- [ ] 사용자 버퍼링과 커널 버퍼링
- [ ] 표준 입출력의 스레드 세이프티

### 고급 파일 입출력

- [ ] 벡터 입출력
- [ ] epoll
- [ ] 메모리맵 입출력
- [ ] 입출력 스케줄러

### 프로세스
